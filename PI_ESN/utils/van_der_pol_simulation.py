import numpy as np


def van_der_pol_oscillator(u, mu=1.0, dt=0.1, initial_state=(2.0, 2.0)):
    """
    Simulate the Van der Pol oscillator using Eulerâ€™s method.

    Parameters
    ----------
    u : np.ndarray
        External input signal (e.g., generated by `generate_signal(config)`).
        The signal defines the control input at each time step.
    mu : float, optional
        Van der Pol parameter controlling nonlinearity and damping (default = 1.0).
    dt : float, optional
        Time step for the Euler integration (default = 0.1).
    initial_state : tuple of floats, optional
        Initial conditions for (x, y). Default = (2.0, 2.0).

    Returns
    -------
    data : np.ndarray
        Array of shape (2, len(u) + 1) containing x(t) and y(t) trajectories.
        data[0, :] = x values
        data[1, :] = y values
    """

    u = np.asarray(u)
    num_steps = len(u)

    xs = np.empty(num_steps + 1)
    ys = np.empty(num_steps + 1)

    # --- Set initial conditions ---
    xs[0], ys[0] = initial_state

    # --- Define the Van der Pol equations ---
    def van_der_pol(x, y, u_value, mu):
        x_dot = y
        y_dot = mu * (1.0 - x**2.0) * y - x + u_value
        return x_dot, y_dot

    # --- Euler integration loop ---
    for i in range(num_steps):
        x_dot, y_dot = van_der_pol(xs[i], ys[i], u[i], mu)
        xs[i + 1] = xs[i] + x_dot * dt
        ys[i + 1] = ys[i] + y_dot * dt

    data = np.asarray([xs, ys])
    return data
